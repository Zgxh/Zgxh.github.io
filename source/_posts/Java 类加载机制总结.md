---
title: Java 类加载机制
date: 2020-9-26 9:59:50
tags: JVM
categories: JVM
mathjax: true
---

# Java 类加载机制总结

## 1. Class 文件

Class 文件中只有两种数据类型： **无符号数**、**表**。

- 无符号数：u1、u2、u4、u8 分别表示 1字节、2字节、4字节、8字节的无符号数。
- 表：由 0 个或多个大小可变的项组成，一个类就相当于一个表。

> **Class 文件中没有任何对齐和填充的说法，所有数据都按照特定的顺序紧凑的排列在 Class 文件中**。
>
> 不像堆中的对象内存一样，会填充为 8 字节的整数倍。

### 1.1 Class 文件的结构

~~~java
ClassFile {
    u4             magic;//魔数
    u2             minor_version;//次版本号
    u2             major_version;//主版本号
    u2             constant_pool_count;//常量池数量
    cp_info        constant_pool[constant_pool_count-1];//常量池信息
    u2             access_flags;//访问标志
    u2             this_class;//类索引
    u2             super_class;//父类索引
    u2             interfaces_count;//接口数(2位，所以一个类最多65535个接口)
    u2             interfaces[interfaces_count];//接口索引 
    u2             fields_count;//字段数
    field_info     fields[fields_count];//字段表集合 
    u2             methods_count;//方法数
    method_info    methods[methods_count];//方法集合
    u2             attributes_count;//属性数
    attribute_info attributes[attributes_count];//属性表集合
}

~~~

## 2. 类加载机制

Java中的类加载、连接和初始化都是在**运行时**完成的，Java的动态扩展的特性就依赖于运行时的动态加载和动态连接。

<img src="http://upload-images.jianshu.io/upload_images/12219352-2d61700695ba47c6.png?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp" alt="类加载过程a" style="zoom:80%;" />

图中前五部分被称为类加载。包括：**加载、验证、准备、解析、初始化**。

### 2.1 类加载的前提：编译

在 JVM 运行之前，java 代码被编译器 javac 编译成 .class 字节码文件。一些类加载时需要用到的编译期知识：

- 编译期间的常量：
    - 编译期间，知道确定值的常量会直接被加入到常量池中，不会经历类加载过程。
    - 不知道确定值的常量，则会在**运行时**对该常量所在的类进行初始化。
        - 如果该`static final`类型是 **基本类型** 或者 **字符串**，则会被编译器标记成`ConstantValue`，后面运行时类加载中的 “**准备**” 阶段会对其进行直接初始化。
- 编译时，编译器会按照代码顺序自动收集类中所有的 **静态变量的赋值动作** 和 **静态语句块** 中的语句，合并产生`<clinit>()`方法。如果没有符合要求的语句，则不生成。
    - （接口因为也有static，所以也会生成`<clinit>()`方法）

### 2.2 加载

加载过程主要做三件事：

1. 通过一个类的全限定名来获取定义此类的**二进制字节流**。
   - 二进制字节流的来源：.class 文件、jar 包等压缩包、网络中获取、动态代理动态生成 .class 文件等
2. 将这个字节流所代表的静态存储结构转化为方法区的**运行时数据结构**。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为**方法区**中该类的各种数据的访问入口。Class类是特殊的对象，不一定分配在堆中，HotSpot虚拟机分配在方法区中。

#### 2.2.1 类加载器

引用类型包括类、接口、数组类、泛型参数。
- 泛型参数会在编译期间进行泛型擦除，不涉及运行时。
- 数组类没有字节流，不通过类加载器进行加载，而是虚拟机直接创建。但是若数组的**组件类型是引用类型**，则递归地去用类加载器加载其组件类型。
- 类和接口通过类加载器去获取字节流。

<img src="http://upload-images.jianshu.io/upload_images/13898040-92981cbcdd89a0fe.png?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp" alt="类加载器a" style="zoom:50%;" />

除了“启动类加载器”，其他类加载器都是`java.lang.ClassLoader`的子类。

- **启动类加载器**：C++实现，没有对应的Java对象。用于加载最基础、最重要的类，如JRE的 /lib 目录下的 jar 包中的类。
- **扩展类加载器**：负责加载次要但通用的类，如JRE的 /lib/ext 目录下 jar 包中的类。
- **应用类加载器**：负责加载应用程序路径下的类。

#### 类加载器的双亲委派机制

- JVM通过双亲委派模型进行类的加载，也可以通过继承`java.lang.ClassLoader`实现自定义的类加载器。
- 当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试子类执行加载任务。
- 采用双亲委派的一个好处是：比如加载类`java.lang.Object`，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。

## 连接

### 1. 验证

确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。

1. **文件格式验证**：保证输入的字节流能正确地解析并存储于方法区之内。
2. **元数据验证**：对类的元数据信息进行语义校验。
3. **字节码验证**：确定程序语义是合法的、符合逻辑的。
4. **符号引用验证**：类对自身以外（常量池中的各种符号引用）的信息进行匹配性校验，目的是确保解析动作能正常执行。

### 2. 准备

为**静态字段**分配内存，这些内存在**方法区**中被分配。并初步设置静态字段的初始值，一般初始化为0（这里的初始化不是值“初始化”阶段的初始化，此时java方法还未被执行，是指初始化为默认初始值）；特例，若该静态字段被`final`修饰，即为静态常量，则直接初始化为设定的值。
- 常量在**编译期**会被添加常量标志`ConstantValue`，“准备”阶段JVM会根据这个标志来判断该直接赋值初始化还是默认初始化。

![默认初始值](http://upload-images.jianshu.io/upload_images/12219352-1c3e74652ae829c4.png?imageMogr2/auto-orient/strip|imageView2/2/w/737/format/webp)

### 3. 解析

虚拟机把常量池内的符号引用替换为**直接引用**的过程。直接引用是直接指向目标的指针等，前提是引用的目标已经在内存中了。

#### 类或接口的解析

若一个类或接口的符号引用未被解析，
1. 如果不是数组类型，则通过全限定名给类加载器去加载该类。
2. 如果是数组类型，且元素类型是对象，则按 1 规则加载其元素类型的类。
3. 解析完成前进行符号引用验证，确认是否有对其的引用访问权限。

#### 字段的解析

#### 类方法解析

#### 接口方法解析

## 初始化

初始化阶段是真正开始执行字节码。这个过程就是`<clinit>()`执行的过程。初始化完成后，类即成为可执行状态。

- 在一个类的`<clinit>()`方法执行前，其父类的`<clinit>()`方法已经执行完毕。因此第一个执行该方法的类肯定是`java.lang.Object`。
- 如果一个实现类或子接口实现了某父接口，则不需要先执行父接口的`<clinit>()`方法。只有当父接口中定义的变量使用时，父接口才会初始化。
- JVM会通过加锁来保证类的`<clinit>()`方法只被执行一次。

### 初始化何时被触发

1. 虚拟机启动时，主类被初始化。
2. `new`一个类时。
3. 调用静态方法或静态字段（除`final`）时，初始化所在的类。
4. 子类的初始化会触发父类的初始化。
5. 若类实现了某定义了`default`方法的接口，则该类的初始化会触发该接口的初始化。
6. 使用反射API对某个类进行反射调用时。


### 被动引用不会触发初始化

1. 通过数组定义类A的引用，不会触发该类的初始化 `A[] = new A[10]`;
2. 通过子类访问父类的静态域时，只有父类会被初始化（即真正声明这个域的类）
3. 引用常量不会导致类的初始化，因为常量在编译期就被加入了常量池。


## Reference

[虚拟机类加载机制 深入理解Java虚拟机总结](https://www.jianshu.com/p/20f902788988)

[深入理解Java类加载机制](https://www.jianshu.com/p/8cab58ac37e3)

[java类到底是如何加载并初始化的？](https://www.cnblogs.com/jimxz/p/3974939.html)

[类加载之 <clinit>() 和 <init>()](https://www.jianshu.com/p/7ff65c3040ec)

[深入理解JVM内存分配和常量池](https://www.cnblogs.com/zzuli/p/9403928.html)