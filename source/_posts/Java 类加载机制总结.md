---
title: Java 类加载机制
date: 2020-9-26 9:59:50
tags: JVM
categories: JVM
mathjax: true
---

# Java 类加载机制总结

## 1. Class 文件

Class 文件中只有两种数据类型： **无符号数**、**表**。

- 无符号数：u1、u2、u4、u8 分别表示 1字节、2字节、4字节、8字节的无符号数。
- 表：由 0 个或多个大小可变的项组成，一个类就相当于一个表。

> **Class 文件中没有任何对齐和填充的说法，所有数据都按照特定的顺序紧凑的排列在 Class 文件中**。
>
> 不像堆中的对象内存一样，会填充为 8 字节的整数倍。

### 1.1 Class 文件的结构

~~~java
ClassFile {
    u4             magic;//魔数
    u2             minor_version;//次版本号
    u2             major_version;//主版本号
    u2             constant_pool_count;//常量池数量
    cp_info        constant_pool[constant_pool_count-1];//常量池信息
    u2             access_flags;//访问标志
    u2             this_class;//类索引
    u2             super_class;//父类索引
    u2             interfaces_count;//接口数(2位，所以一个类最多65535个接口)
    u2             interfaces[interfaces_count];//接口索引 
    u2             fields_count;//字段数
    field_info     fields[fields_count];//字段表集合 
    u2             methods_count;//方法数
    method_info    methods[methods_count];//方法集合
    u2             attributes_count;//属性数
    attribute_info attributes[attributes_count];//属性表集合
}

~~~

## 2. 类加载机制

Java中的类加载、连接和初始化都是在**运行时**完成的，Java的动态扩展的特性就依赖于运行时的动态加载和动态连接。

<img src="http://upload-images.jianshu.io/upload_images/12219352-2d61700695ba47c6.png?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp" alt="类加载过程a" style="zoom:80%;" />

图中前五部分被称为类加载。包括：**加载、验证、准备、解析、初始化**。

### 2.1 类加载的前提：编译

在 JVM 运行之前，java 代码被编译器 javac 编译成 .class 字节码文件。一些类加载时需要用到的编译期知识：

- 编译期间的常量：
    - 编译期间，知道确定值的常量会直接被加入到常量池中，不会经历类加载过程。
    - 不知道确定值的常量，则会在**运行时**对该常量所在的类进行初始化。
        - 如果该`static final`类型是 **基本类型** 或者 **字符串**，则会被编译器标记成`ConstantValue`，后面运行时类加载中的 “**准备**” 阶段会对其进行直接初始化。
- 编译时，编译器会按照代码顺序自动收集类中所有的 **静态变量的赋值动作** 和 **静态语句块** 中的语句，合并产生`<clinit>()`方法。如果没有符合要求的语句，则不生成。
    - （接口因为也有static，所以也会生成`<clinit>()`方法）

### 2.2 加载 Loading

加载过程主要做三件事：

1. 通过一个类的全限定名来获取定义此类的**二进制字节流**。
   - 二进制字节流的来源：.class 文件、jar 包等压缩包、网络中获取、动态代理动态生成 .class 文件等
2. 将这个字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为**方法区**中该类的各种数据的访问入口。
   - Class类是特殊的对象，不一定分配在堆中，Hot Spot 虚拟机分配在方法区中。

#### 2.2.1 类加载器

引用类型包括类、接口、数组类、泛型参数。
- 泛型参数会在编译期间进行泛型擦除，不涉及运行时。
- 数组类没有字节流，不通过类加载器进行加载，而是虚拟机直接创建。但是若数组的**组件类型是引用类型**，则递归地去用类加载器加载其组件类型。
- 类和接口通过类加载器去获取字节流。

<img src="http://upload-images.jianshu.io/upload_images/13898040-92981cbcdd89a0fe.png?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp" alt="类加载器a" style="zoom:50%;" />

除了“启动类加载器”，其他类加载器都是`java.lang.ClassLoader`的子类。

- **启动类加载器**：C++实现，没有对应的Java对象。用于加载最基础、最重要的类，如JRE的 /lib 目录下的 jar 包中的类。
- **扩展类加载器**：负责加载次要但通用的类，如JRE的 /lib/ext 目录下 jar 包中的类。
- **应用类加载器**：负责加载应用程序路径下的类。

#### 2.2.2 双亲委派机制

> 当一个类加载器收到类加载任务，它自己首先**不会**自己主动去加载这个类，而是先交给其**父类加载器**去尝试加载，直到传递到顶层的**启动类加载器**。只有当父类加载器无法完成加载任务时，才会尝试**子类加载器**执行加载任务。
>
> **双亲委派机制保证了**：对同一个类，不管是哪个加载器加载这个类，最终都是委托给可能的最顶层的类加载器进行加载，来保证使用不同的类加载器都会得到相同的 Object 对象。

<img src="http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/2A8C9B8B5D744E08ABAEA94B4CD8B3AB/9138" alt="a" style="zoom:70%;" />

- **启动类加载器** (Bootstrap ClassLoader)：负责加载 `$JAVA_HOME\lib` 下的类或者被参数 `-Xbootclasspath` 指定的能被虚拟机识别的类(通过jar名字识别，如：rt.jar)，启动类加载器**由 Java 虚拟机直接控制**，开发者不能直接使用启动类加载器。
  - 启动类加载器没有子类，但是在**逻辑上**当扩展类加载器会将收到的类加载请求传递给启动类加载器来进行优先加载。

- **扩展类加载器** (Extension ClassLoader)：负责加载 `$JAVA_HOME\lib\ext` 下的类，或者被 `java.ext.dirs` 系统变量指定路径中的所有类库( `System.getProperty(“java.ext.dirs”)` )，开发者可以直接使用这个类加载器。

- **应用程序类加载器** (Application ClassLoader)，负责加载 `$CLASS_PATH` 中指定的类库。开发者能直接使用这个类加载器。
  - 正常情况下如果没有自定义类加载器，一般用的就是这个类加载器。

- **自定义类加载器**：可以通过继承 `java.lang.ClassLoader` 来自定义类加载器,一般我们都选择继承 `URLClassLoader` 来进行适当的改写就可以了。

> 可以通过继承  `java.lang.ClassLoader` ，并重写其中的 `loadClass()` 方法来破坏双亲委派机制。

### 2.3 连接 Linking

#### 2.3.1 验证 Verification

确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。

1. **文件格式验证**：比如说是不是以魔数开头，jdk 版本号的正确性等等。
2. **元数据验证**：比如说类中的字段是否合法，是否有父类，父类是否合法等等。
3. **字节码验证**：确定程序语义是合法的、符合逻辑的。
4. **符号引用验证**：类对自身以外（常量池中的各种符号引用）的信息进行匹配性校验，目的是确保解析动作能正常执行。

#### 2.3.2 准备 Preparation

为类或接口的**静态字段** `static`（类变量、静态常量）分配内存（在**方法区**中），并初始化为**默认值**。

- 若不是 `static final`，该初始值指的是类型对应的**默认初始值**（如下表），并非开发者对变量赋值的初值。
- 若为 `static final`，即为静态常量，则直接初始化为赋予的初始值。
  - 常量在**编译期**会被添加常量标志 `ConstantValue`，JVM 以此来判断是不是常量。

![默认初始值](http://upload-images.jianshu.io/upload_images/12219352-1c3e74652ae829c4.png?imageMogr2/auto-orient/strip|imageView2/2/w/737/format/webp)

#### 2.3.3 解析 Resolution

解析是虚拟机把常量池内的**符号引用**替换为**直接引用**的过程。直接引用是**直接指向目标的指针**等，**前提**是引用的目标已经在内存中了（这也意味着解析阶段必须在准备阶段之后，因为准备阶段才正式开始分配内存）。

- **符号引用**：符号可以是任意形式的字面量，该符号可以唯一定位到引用的目标。
- **直接引用**：直接指向目标的指针、相对偏移量、或是一个能间接定位到目标的句柄。

> 因为 Java 支持动态绑定，所以有些引用要等到具体使用的时候才会知道指向，所以**解析可以在初始化之后进行**。

##### 2.3.3.1 类或接口的解析

若一个类或接口的符号引用未被解析，
1. 如果不是数组类型，则通过全限定名给类加载器去加载该类。
2. 如果是数组类型，且元素类型是对象，则按 1 规则加载其元素类型的类。
3. 解析完成前进行符号引用验证，确认是否有对其的引用访问权限。

##### 2.3.3.2 字段的解析

##### 2.3.3.3 类方法解析

##### 2.3.3.4 接口方法解析

### 2.4 初始化 Initialization

初始化阶段是真正开始执行字节码进行赋值操作，会把准备阶段的默认值替换为真正的初始值。初始化过程会执行构造器方法。

初始化过程就是`<clinit>()`执行的过程。初始化完成后，类即成为可执行状态。

- 在一个类的`<clinit>()`方法执行前，其父类的`<clinit>()`方法已经执行完毕。因此第一个执行该方法的类肯定是`java.lang.Object`。
- 如果一个实现类或子接口实现了某父接口，则不需要先执行父接口的`<clinit>()`方法。当父接口中的某些属性被使用到的时候才会触发父接口的初始化。
- JVM 会通过加锁来保证类的`<clinit>()`方法只被执行一次。

#### 2.4.1 初始化何时被触发

JVM 规定了 5 种情况必须进行**立即**初始化，也被称为**主动引用**。

1. 当虚拟机启动时，主类（main 方法所在的类）被初始化。
2. `new` 实例化一个类对象时；或者调用或设置某类的静态方法或静态字段（除`final`）时，初始化所在的类。
4. 当初始化子类时，如果父类还没初始化，则先触发父类的初始化。若类实现了某定义了`default`方法的接口，则该类的初始化会触发该接口的初始化。
6. 使用反射 API 对某个类进行反射调用时。
5. JDK 1.7 开始提供的**动态语言支持**，如果一个 `java.lang.invoke.MethodHandle` 实例解析的结果`REF_getStatic`，`REF_putStatic`，`REF_invokeStatic` 的方法句柄对应的类没有被初始化，需要触发其初始化。

##### 2.4.2.1 对于父接口

当接口被初始化时，不要求其父接口全部初始化，只有真正使用到父接口时才会触发父接口的初始化。如使用到了父接口中定义的常量等。

##### 2.4.2.1 对于数组

~~~java
Object[] arr = new Object[10];
~~~

构造数组对象和直接构造对象是用过不同的字节码来实现的，创建数组对象是通过 `newarray` 指令来实现，所以并不会初始化 Object 对象。


#### 2.4.2 被动引用不触发初始化

1. 通过**数组**定义类 A 的引用，不会触发该类 A 的初始化 `A[] = new A[10]`;
2. 通过子类访问父类的**静态域**时，只有父类会被初始化（即真正声明这个域的类）。
3. 引用常量不会导致类的初始化，因为常量在编译期就被加入了常量池。


## Reference

[虚拟机类加载机制 深入理解Java虚拟机总结](https://www.jianshu.com/p/20f902788988)

[深入理解Java类加载机制](https://www.jianshu.com/p/8cab58ac37e3)

[java类到底是如何加载并初始化的？](https://www.cnblogs.com/jimxz/p/3974939.html)

[类加载之 <clinit>() 和 <init>()](https://www.jianshu.com/p/7ff65c3040ec)

[深入理解JVM内存分配和常量池](https://www.cnblogs.com/zzuli/p/9403928.html)