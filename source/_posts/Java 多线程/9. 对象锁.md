---
title: Java 对象锁
date: 2020-11-06 16:25:25
tags: 多线程与并发
categories: 多线程与并发
---

## 9. 锁

**Java中的锁都是对象锁**，Class 类是特殊的 Java 对象，所以类锁也是对象锁。

- 每个类只有一个 Class 对象，类锁就是 Class 对象的锁。

#### 为什么任意一个 Java 对象都能成为锁对象？

对象派生自 `Object`，每个 Java 对象都会对应一个监视器 Monitor Object，底层是基于 C++ 实现的，这个 Monitor 维护了 mutex 互斥量以及线程阻塞与唤醒的 API。

`synchronized` 对对象加锁时，就是通过对象内置的 Monitor 来加锁的。

### 9.1 临界区

临界区就是一块互斥的代码区域，它在同一时刻只能由一个线程执行。

### 9.2 锁的分类

Java 6 之前，所有的 `synchronized` 锁都是重量级锁，是利用了对象的监视器 Monitor，本质是利用了操作系统的互斥量 Mutex；Java 6 之后，对 `synchronized` 锁进行了优化，有四种对象锁状态：
1. **无锁**
2. **偏向锁**
3. **轻量级锁**
4. **重量级锁**

偏向锁 和 轻量级锁 是对 `synchronized` 的优化，但是锁竞争激烈时，反而会降低执行效率。

锁会随着锁竞争发生**锁升级**。锁状态只能升级，不能降级。

[美团技术团队-不可不说的锁事](https://tech.meituan.com/2018/11/15/java-lock.html)

#### 9.2.1 Java 对象头

Java 对象头的组成：
1. `Mark Word`
2. 指向类信息的指针 `Klass Pointer`
3. 数组的长度

![对象头信息](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/4098CB7903B94C2289BC15C32FFE94BF/8890)

##### Mark Word

`Mark Word` 在 32 位 JVM 中的长度是 32 bit，在 64 位 JVM 中长度是 64bit。以 32 位为例：
- 使用 1 bit 来指示 是否为偏向锁
- 使用 2 bit 来标志 锁的状态

`Mark Word` 用来存放对象信息或锁信息。`Mark Word` 被设计成可以复用的形式，
- 当对象是**无锁态**时，`Mark Word` 记录对象的 hashCode，锁标志位是 01，是否为偏向锁位为 0；
- 当对象锁为**偏向锁**时，锁标志位依然是 01，是否为偏向锁位为 1，`Mark Word` 的前 23 位标志占有偏向锁的线程 id；
- 当对象锁为**轻量级锁**时，锁标志位是 00，前 30 位指向栈帧中锁记录的指针
- 当对象锁位**重量级锁**时，锁标志位是 10，前 30 位为指向重量级锁的指针

![](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/B7669EB5178041248F525FB44AC284E2/13025)

##### Klass Pointer

对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

#### 9.2.2 偏向锁

引入偏向锁，是为了在**无多线程竞争**的情况下，尽量减少不必要的资源占用。
- 偏向锁会在资源无竞争的情况下消除同步语句
- 偏向的意思是：偏向锁总会偏向与第一个访问锁的线程
- 偏向锁会在 **对象头** 中 记录 **线程 ID**
- 偏向锁在有线程竞争锁的时候才会释放锁

##### 偏向锁的原理

一个线程在**第一次**进入同步块的时候，会在对象头和栈帧中记录偏向锁的线程 id，当下一次该线程再次进入同步块的时候，会检查 `Mark Word` 中的线程 id 是否为当前线程:
- 如果是当前线程，则说明当前线程已经获得了锁，以后该线程进入和退出同步块时，不需要通过 CAS 来加锁和解锁
- 如果不是当前线程，则说明有其他线程来竞争该偏向锁。此时会尝试通过 CAS 操作来替换 `Mark Word` 中的线程 id 为当前线程的 id：
    - 如果 CAS 成功执行，则表示之前竞争锁的线程不存在了，锁不会升级，依然是偏向锁
    - 如果 CAS 执行失败，则表示之前竞争锁的线程依然存在，则暂停之前的线程，并把偏向锁标识设置为 `0`，线程 id 设为空；同时锁升级为**轻量级锁**，锁标志位设为 `00`；然后唤醒被停止的线程。
        - 之后的锁竞争将按照轻量级锁的方式进行。

![](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/4076FDBA616E4A178978CD27D5070783/12666)

##### 偏向锁的释放

偏向锁的释放总是在有线程竞争该偏向锁的时候。

偏向锁进行锁升级时，会在**全局安全点**暂停之前占有偏向锁的线程，并重置偏向锁标志，这个**开销很大**。
- 若进程中锁经常处于竞争状态，则不应设置偏向锁。
- 偏向锁**默认开启**，关闭偏向锁的方式：`-XX:-UseBiasedLocking=false`，关闭后默认进入**轻量级锁**状态。
- **全局安全点**：在该时间节点上，没有字节码正在执行

之前拥有锁的线程被暂停后，在恢复线程时，首先会判断偏向的线程是否还存在（有可能全局安全点就是线程结束的点），然后选择恢复之前的线程，或者把对象头设置为无锁状态。

![](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/2CEFD38921E74AD6B240DCF315B6D98E/13575)

##### 锁升级的过程
1. 在一个全局安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和 `Mark Word`，使其变成无锁状态。
3. 唤醒被停止的线程，将当前锁升级成轻量级锁。

#### 9.2.3 轻量级锁

当多个线程在不同时间段获取同一把锁时，锁不存在竞争的情况，此时不存在线程阻塞。此时，采用**轻量级锁**来避免线程的阻塞与唤醒，从而减少重量级锁带来的性能消耗。
- 轻量级锁通过**自旋**的方式来尝试获取锁，不会阻塞线程
- 轻量级锁对象的对象头中 `Mark Word` 指向线程栈的栈帧中的**锁记录**。

##### 栈帧中的锁记录 Lock Record

在代码进入同步块时，如果同步对象锁状态为**无锁**状态（锁标志位为“01”状态，是否为偏向锁为“0”）:
1. 虚拟机首先将在当前线程的**栈帧**中建立一个名为**锁记录**（Lock Record）的空间，用于存储锁对象目前的 `Mark Word` 的拷贝
2. 然后拷贝对象头中的 `Mark Word` 到锁记录中。
3. 拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 `Mark Word` 更新为指向 `Lock Record` 的指针，并将 `Lock Record` 里的 **owner 指针**指向对象的 `Mark Word`。

![轻量级锁的加锁与释放](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/2C14F9A8A8424636B194A1848D56D6B7/12758)

##### 轻量级锁的加锁

虚拟机栈栈帧中会存储每个线程的**锁记录**，称为 `Displaced Mark Word`。
1. 若线程获得锁时发现是轻量级锁，则把 `Mark Word` 复制到 `Displaced Mark Word` 中
2. 线程尝试 CAS 操作，将锁的 `Mark Word` 替换为指向栈帧中锁记录的指针：
    - 若成功替换，则当前线程成功获得锁；
    - 若替换失败，则表示 `Mark Word` 已经被替换成其他线程的锁记录指针，说明存在竞争锁的线程，则当前线程自旋请求锁。

##### 适应性自旋

自旋来请求锁会一直占用 CPU，JDK 采用 **适应性自旋** 来避免 CPU 一直被占用：
- 若线程自旋请求锁成功，则下次竞争锁时的可自旋次数增加
- 若线程自旋请求锁失败，则下次竞争锁时的可自旋次数减少

##### 自旋失败 与 轻量级锁升级

当线程自旋到一定程度，依然没有获取到锁，则**自旋失败**，**阻塞**该线程。同时该轻量级**锁升级**为重量级锁。

##### 轻量级锁的释放

轻量级锁释放时，当前持有锁的线程会进行 CAS 操作，将 `Displaced Mark Word` 的内容复制回 `Mark Word`:
- 如果没有锁竞争，那么这个复制的操作会成功
- 如果之前有其他线程自旋失败导致轻量级锁升级成了重量级锁，那么 CAS 操作会失败，此时当前线程会释放锁并唤醒被阻塞的线程（自旋失败的线程）。
    - 被唤醒的线程会重新争夺锁

#### 9.2.4 重量级锁

重量级锁依赖于操作系统的**互斥量**（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。
- 当对象锁为重量级锁时，`Mark Word` 中存储的是指向重量级锁（互斥量）的指针
- 等待重量级锁的线程都会进入阻塞状态 
- 当调用一个锁对象的 `notify()` 或 `wait()` 方法时，首先会将锁**膨胀**成重量级锁

#### 9.2.5 锁的升级流程

当线程想要获取共享资源时：
1. 首先检查 `Mark Word` 中的线程 id 是不是自身，如果是，则对象锁为偏向锁；
2. 如果不是自己的线程 id，则尝试使用 CAS 操作来把 `Mark Word` 中的线程 id 修改为本线程的id，如果修改失败，则说明当前存在锁竞争，此时暂停正在占有锁的线程，并修改线程 id 为空，偏向锁升级为轻量级锁。之后恢复被暂停的线程。
3. 轻量级锁的线程，会在栈帧中新建锁记录，线程把锁对象的 hashcode 复制到对应的锁记录中，然后通过 CAS 操作把 `Mark Word` 修改为指向锁记录的指针。
4. 成功修改 `Mark Word` 的线程会获得轻量级锁，失败的线程自旋。
5. 若自旋的线程在自旋中成功获得了锁，则轻量级锁不会升级；
6. 如果自旋失败，则轻量级锁升级为重量级锁。此时，未获得锁的线程会阻塞，等待持有锁的线程在同步块内执行完成，并唤醒自己。从而重新进行锁竞争。

#### 9.2.6 各种锁的对比

- **偏向锁** 是通过对比 Mark Word 来避免执行 CAS 操作
- **轻量级锁** 是通过 CAS 操作和自旋来避免线程阻塞和唤醒，而影响性能
- **重量级锁** 是将除了拥有锁的线程以外的其他线程直接阻塞

![](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/41C8A6DEB67B4DBA816F1BD5C96D5635/12783)


### 9.3 乐观锁与悲观锁

![](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/45FBCEC3BF6643D9A65FAF87FBF23D2A/12618)

#### 9.3.1 乐观锁

乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁，也无需等待。

一旦多个线程发生冲突，则是使用 CAS 来解决线程安全性问题。

乐观锁默认不加锁，所以不会出现死锁。

乐观锁适用于 “多读少写” 的情况，避免冲突时频繁加锁，影响性能。

#### 9.3.2 悲观锁

悲观锁总是假设访问共享资源会发生冲突，所以每次都会加锁，以保证临界区同时只有一个线程在执行。
- `synchronized` 和 `Lock` 的实现类 都是悲观锁。

悲观锁适用于 “多写少读” 的情况，避免频繁的失败和重试影响性能。

