---
title: Fork/Join框架
date: 2020-11-06 16:25:25
tags: 多线程与并发
categories: 多线程与并发
---

# Fork/Join 框架

Java 7 开始引入了一种新的 Fork/Join 机制，它实现了类似于分治的思想：把一个大任务拆成多个小任务并行执行。

- 判断一个任务是否足够小，如果足够小，则直接进行计算；
- 否则，拆分成小任务，并分别计算。
- 最后将小任务的结果结合得到大任务的结果

`Fork/Join` 框架包括：

1. 分治任务线程池 `ForkJoinPool`
2. 分治任务 `ForkJoinTask`
3. 分治任务工作线程 `ForkJoinWorkerThread`

## 1. 工作窃取 Work-Stealing

`Fork/Join` 框架就是基于工作窃取算法。

多线程协作时，一个线程执行完了自己**任务队列**中的任务后，去别的线程的任务队列中窃取还没执行的任务进行执行。

- 任务队列是**双端队列**，本线程从头获取任务，窃取任务的线程从尾获取任务。
- 当没有可以窃取的任务时，该线程自动阻塞，等待下次工作。

## 2. ForkJoinTask

`ForkJoinTask` 抽象类为 Fork/Join 框架提供任务。

```java
volatile int status; // 当前任务对象的执行状态
static final int DONE_MASK   = 0xf0000000;  // mask out non-completion bits
static final int NORMAL      = 0xf0000000;  // must be negative
static final int CANCELLED   = 0xc0000000;  // must be < NORMAL
static final int EXCEPTIONAL = 0x80000000;  // must be < CANCELLED
static final int SIGNAL      = 0x00010000;  // must be >= 1 << 16
static final int SMASK       = 0x0000ffff;  // short bits for tags
```

`ForkJoinTask` 的核心操作是 `fork()`方法与 `join()` 方法。

### 2.0 使用 ForkJoinTask 来处理分治任务

```java
public class FunctionTest {

    public static void main(String[] args) {
        // 建分治任务线程池
        ForkJoinPool forkJoinPool = new ForkJoinPool(4);
        // 建分治任务
        Fib fib = new Fib(4);
        // 启动分治任务
        Integer result = forkJoinPool.invoke(fib);
        System.out.println(result);

//        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
//        numbers.parallelStream().forEach(System.out::println);


    }
}

class Fib extends RecursiveTask<Integer> {
    int n;

    Fib(int n) {
        this.n = n;
    }

    @Override
    protected Integer compute() {
        // 如果分治到了足够小，则直接执行
        if (n <= 1) {
            return n;
        }
        // 如果任务不够小，继续分治
        // 分离第一个子任务，并启动异步执行
        Fib task1 = new Fib(n - 1);
        task1.fork();
        // 分离第二个子任务，并启动异步执行
        Fib task2 = new Fib(n - 2);
        task2.fork();
        // 调用两个任务的 join() 来获得运行结果
        Integer result1 = task1.join();
        Integer result2 = task2.join();

        return result1 + result2;
    }
}
```



### 2.1 任务提交

`fork()` 方法会把切分后的任务加入到当前的工作线程的队列中，用于**异步执行**任务。

- 异步是指操作提交后，可以继续执行其他操作。

~~~java
public final ForkJoinTask<V> fork() {
    Thread t;
    // 把该任务提交到当前的 ForkJoinWorkerThread 线程中的工作队列中
    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
        ((ForkJoinWorkerThread)t).workQueue.push(this);
    else
        ForkJoinPool.common.externalPush(this);
    return this;
}
~~~

### 2.2 任务的消费

`join()` 等待任务执行成功，并获取执行结果。

`doExec()`是真正的执行任务，调用路径：`doExec()`->`exec()`->`compute()`

- 每次工作线程 `ForkJoinWorkerThread` 获得任务后，先判断任务的执行状态，因为该任务可能会被别的线程截获并执行完成了。

```java
public final V join() {
    int s;
    if ((s = doJoin() & DONE_MASK) != NORMAL)
        reportException(s);
    // 如果任务正常执行完成了，则返回执行结果
    return getRawResult();
}

// 尝试去获取该任务的执行状态，返回的是任务的执行状态 s
private int doJoin() {
    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
    return (s = status) < 0 ? s : // 如果执行完毕了，则直接返回任务执行状态
        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
        (w = (wt = (ForkJoinWorkerThread)t).workQueue).
        tryUnpush(this) && (s = doExec()) < 0 ? s : // 如果该任务位于队列头，则弹出并执行 doExec()
        wt.pool.awaitJoin(w, this, 0L) : // 如果不在队列头，则自旋判断任务是否执行成功
        externalAwaitDone();
}

// 自旋判断任务是否执行成功，直到任务完成或者超时
final int awaitJoin(WorkQueue w, ForkJoinTask<?> task, long deadline) {
    int s = 0;
    if (task != null && w != null) {
        ForkJoinTask<?> prevJoin = w.currentJoin;
        U.putOrderedObject(w, QCURRENTJOIN, task);
        CountedCompleter<?> cc = (task instanceof CountedCompleter) ?
            (CountedCompleter<?>)task : null;
        // 轮询任务是否执行完成，如果没完成就继续尝试出队并执行
        for (;;) {
            if ((s = task.status) < 0)
                break;
            if (cc != null)
                helpComplete(w, cc, 0);
            else if (w.base == w.top || w.tryRemoveAndExec(task))
                helpStealer(w, task);
            if ((s = task.status) < 0)
                break;
            long ms, ns;
            if (deadline == 0L)
                ms = 0L;
            else if ((ns = deadline - System.nanoTime()) <= 0L)
                break;
            else if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) <= 0L)
                ms = 1L;
            if (tryCompensate(w)) {
                task.internalWait(ms);
                U.getAndAddLong(this, CTL, AC_UNIT);
            }
        }
        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);
    }
    return s;
}
```

#### 2.3 实现类

`ForkJoinTask` 的两个实现类：

- `RecursiveAction`：使用递归的方式来处理分治任务，其 `compute()` 方法没有返回值。
- `RecursiveTask` ：使用递归的方式来处理分治任务，其 `compute()` 方法有返回值。



以 `RecursiveTask` 为例：

```java
public abstract class RecursiveTask<V> extends ForkJoinTask<V> {
    private static final long serialVersionUID = 5232453952276485270L;

    // 存放计算结果
    V result;

    // 执行分治计算，并返回计算结果
    protected abstract V compute();

    // 获取计算结果
    public final V getRawResult() {
        return result;
    }

    protected final void setRawResult(V value) {
        result = value;
    }

    // 调用 compute() 方法执行任务，然后返回执行状态
    protected final boolean exec() {
        result = compute();
        return true;
    }

}
```



## 3. ForkJoinPool

`ForkJoinPool` 是 `Fork/Join` 框架下的分治任务线程池。它只运行分治任务 `ForkJoinTask`。

```java
volatile long ctl;                   // main pool control
volatile int runState;               // lockable status
```



### 3.1 工作队列 ForkJoinPool.WorkQueue

工作队列是 `ForkJoinPool` 的核心数据结构，是支持**工作窃取**的双端队列。工作队列是属于某个 `ForkJoinWorkerThread` 的。



## 4. ForkJoinWorkerThread

`ForkJoinWorkerThread` 用来执行分治任务 `ForkJoinTask`。

```java
public class ForkJoinWorkerThread extends Thread {

    final ForkJoinPool pool;                // 该线程对应的池
    final ForkJoinPool.WorkQueue workQueue; // 该线程的工作任务队列
}
```

