---
title: Fork/Join框架
date: 2020-11-06 16:25:25
tags: 多线程与并发
categories: 多线程与并发
---

# Fork/Join 框架

Java 7 开始引入了一种新的 Fork/Join 机制，它实现了类似于分治的思想：把一个大任务拆成多个小任务并行执行。

- 判断一个任务是否足够小，如果足够小，则直接进行计算；
- 否则，拆分成小任务，并分别计算。
- 最后将小任务的结果结合得到大任务的结果

## 1. 工作窃取算法

多线程协作时，一个线程执行完了自己**任务队列**中的任务后，去别的线程的任务队列中窃取还没执行的任务进行执行。

- 任务队列是**双端队列**，本线程从头获取任务，窃取任务的线程从尾获取任务。
- 当没有可以窃取的任务时，该线程自动阻塞，等待下次工作。

## 2. ForkJoinTask

`ForkJoinTask` 抽象类为 Fork/Join 框架提供任务。

```java
volatile int status; // 当前任务对象的执行状态
static final int DONE_MASK   = 0xf0000000;  // mask out non-completion bits
static final int NORMAL      = 0xf0000000;  // must be negative
static final int CANCELLED   = 0xc0000000;  // must be < NORMAL
static final int EXCEPTIONAL = 0x80000000;  // must be < CANCELLED
static final int SIGNAL      = 0x00010000;  // must be >= 1 << 16
static final int SMASK       = 0x0000ffff;  // short bits for tags
```

### 2.1 任务提交

`fork()` 方法会把切分后的任务加入到当前的工作线程的队列中，用于异步执行任务。

~~~java
public final ForkJoinTask<V> fork() {
    Thread t;
    // 把该任务提交到当前的 ForkJoinWorkerThread 线程中的工作队列中
    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
        ((ForkJoinWorkerThread)t).workQueue.push(this);
    else
        ForkJoinPool.common.externalPush(this);
    return this;
}
~~~

### 2.2 任务的消费

`join()` 等待任务执行成功，并获取执行结果。

`doExec()`是真正的执行任务，调用路径：`doExec()`->`exec()`->`compute()`

- 每次工作线程 `ForkJoinWorkerThread` 获得任务后，先判断任务的执行状态，因为该任务可能会被别的线程截获并执行完成了。

```java
public final V join() {
    int s;
    if ((s = doJoin() & DONE_MASK) != NORMAL)
        reportException(s);
    // 如果任务正常执行完成了，则返回执行结果
    return getRawResult();
}

// 尝试去获取该任务的执行状态，返回的是任务的执行状态 s
private int doJoin() {
    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
    return (s = status) < 0 ? s : // 如果执行完毕了，则直接返回任务执行状态
        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
        (w = (wt = (ForkJoinWorkerThread)t).workQueue).
        tryUnpush(this) && (s = doExec()) < 0 ? s : // 如果该任务位于队列头，则弹出并执行 doExec()
        wt.pool.awaitJoin(w, this, 0L) : // 如果不在队列头，则自旋执行任务
        externalAwaitDone();
}

// 自旋判断任务是否执行成功，直到任务完成或者超时
final int awaitJoin(WorkQueue w, ForkJoinTask<?> task, long deadline) {
    int s = 0;
    if (task != null && w != null) {
        ForkJoinTask<?> prevJoin = w.currentJoin;
        U.putOrderedObject(w, QCURRENTJOIN, task);
        CountedCompleter<?> cc = (task instanceof CountedCompleter) ?
            (CountedCompleter<?>)task : null;
        // 轮询任务是否执行完成
        for (;;) {
            if ((s = task.status) < 0)
                break;
            if (cc != null)
                helpComplete(w, cc, 0);
            else if (w.base == w.top || w.tryRemoveAndExec(task))
                helpStealer(w, task);
            if ((s = task.status) < 0)
                break;
            long ms, ns;
            if (deadline == 0L)
                ms = 0L;
            else if ((ns = deadline - System.nanoTime()) <= 0L)
                break;
            else if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) <= 0L)
                ms = 1L;
            if (tryCompensate(w)) {
                task.internalWait(ms);
                U.getAndAddLong(this, CTL, AC_UNIT);
            }
        }
        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);
    }
    return s;
}
```



## 3. ForkJoinPool

`ForkJoinPool` 线程池。

## 4. ForkJoinWorkerThread

```java
public class ForkJoinWorkerThread extends Thread {

    final ForkJoinPool pool;                // 该线程对应的池
    final ForkJoinPool.WorkQueue workQueue; // 该线程的工作任务队列
}
```

