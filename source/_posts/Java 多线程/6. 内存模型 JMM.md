---
title: 6.内存模型 JMM
date: 2020-11-06 16:25:25
tags: 多线程与并发
categories: 多线程与并发
---

## 6. Java 内存模型

### 6.1 并发模型

线程间进行通信和同步，可以通过 2 种方式的并发模型来实现：
1. 消息传递并发模型
2. 共享内存并发模型

![](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/9E9DB40CE7334B3996E5ABA28365656D/12316)

Java 中，采用的是第二种：**共享内存并发模型**

### 6.2 JVM 运行时数据区

![java运行时数据区](http://concurrent.redspider.group/article/02/imgs/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

- 方法区 和 堆，是对所有线程内存共享的。
- 栈、PC 是线程私有的。

Java 中内存可见性是指堆中的共享变量。

### 6.3 Java 内存模型 JMM

Java 的并发是通过**共享内存**来实现的。

JMM 定义了 **线程** 与 **主内存** 之间的抽象关系。
- 所有的共享变量都在主内存中
- 每个线程保存一份共享变量的副本

**线程之间通信需要以主内存为媒介**，而 JMM 来控制 **主内存** 与 **本地内存** 的交互：
- 线程对共享变量的操作必须在线程自己的**本地内存**中进行
- 线程通信需要一个线程先把线程中的共享变量更新到主内存
- 然后另一个线程从主内存中读取刷新后的共享变量

![JMM内存模型](http://concurrent.redspider.group/article/02/imgs/JMM%E6%8A%BD%E8%B1%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

#### 6.3.1 volatile 关键字

- 保证多线程操作共享变量的可见性
- 禁止指令重排序

具体看对 `volatile` 关键字的介绍。

#### 6.3.2 JMM 与 运行时数据区 的关系

JMM 是抽象的概念。
- JMM 的主内存属于共享数据区域，包含堆、方法区；
- JMM 的本地内存属于私有数据区域，包含程序计数器、本地方法栈、虚拟机栈。