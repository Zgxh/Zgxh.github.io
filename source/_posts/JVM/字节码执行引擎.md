---
title: 字节码执行引擎
date: 2020-9-26 9:59:50
tags: JVM
categories: JVM
mathjax: true
---

# JVM 字节码执行引擎

JVM 输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 1. JVM 运行时数据结构

详情看 [JVM 内存结构总结]。

## 2. 方法调用

方法调用是指确定方法的版本，不涉及方法内部的执行过程。

一切方法调用在 .class 文件里存储的都只是**符号引用**，这是需要在**类加载**期间或者是**运行期**间，才能确定为方法在实际 运行时内存布局中的入口地址（相当于类加载中解析阶段中把符号引用替换为**直接引用**）。

### 2.1 类加载中对方法调用的解析

类加载的解析，是对 class 文件中的符号引用转化为 JVM 内存结构中的直接引用。

JVM 中方法调用字节码的指令：
- invokestatic: 调用静态方法
- invokespecial: 调用实例构造器方法、私有方法、父类方法
- invokevirtual: 调用所有的虚方法：可以被重写的方法
- invokeinterface：调用接口方法
- invokedynamic: 用来实现动态语言特性。先在运行时动态解析出点限定符锁引用的方法，然后执行该方法。

### 2.2 方法的分派调用

分派是多态的体现。体现在方法的**重载**与**重写**上。

```java
List<Integer> list = new ArrayList();
```

`List` 是**静态类型**，`ArrayList` 是**实际类型**。
- 静态类型在**编译期**确定
- 实际类型在**运行时**才确定

#### 2.2.1 静态分派

静态分派是指依赖静态类型来绑定方法的直接引用，的分派行为，在编译阶段完成。
- 静态分派应用于方法的**重载**调用。

区分被重载的函数取决于方法签名。
- 方法名
- 参数类型
- 参数个数

被重载函数的调用时，方法参数类型取决于静态类型，即编译器即确定了方法参数类型。

#### 2.2.2 动态分派

动态分派是指，在运行时，根据实际类型确定方法版本的分派过程。
- 应用是方法的**重写**。

若类 A 的实际类型是子类，则调用类 A 的重写方法，是通过动态分派来确定的。

##### 动态分派的实现

动态方法是利用了 JVM 方法区中的 **虚方法表** Virtual Method Table, 存放各个虚方法的实际入口地址。
- 若子类方法没有重写父类方法，则指向父类的实现。
- 若子类方法重写了父类方法，则指向子类方法。

虚方法表一般在类加载的连接阶段进行初始化。

[qianzhaokun-Java方法的调用过程](https://qinzhaokun.github.io/2017/08/01/Java%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%EF%BC%89/)






