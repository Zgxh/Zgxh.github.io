---
title: 垃圾回收机制
date: 2020-9-26 9:59:50
tags: JVM
categories: JVM
mathjax: true
---

# Java 堆内的垃圾回收 GC

![堆的GC](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/18FF35D98E7B4C84A637F1EDB0CD91F5/8810)

## 1. GC 的分类
GC 分为 :
- ==minor GC== ： 发生在 Eden 区满的时候，**回收范围为 年轻代**。
- ==full GC== ： 发生在老年代满的时候，**回收范围是 年轻代 + 老年代**。
> 发生 GC 时会产生 **STW （Stop the World）机制**，暂停 **应用线程** 的运行，安心进行 GC。而 full GC 会导致 STW 时间更长，因此 JVM 调优就要减少 full GC 的次数。
>
> 发生 STW 的原因是避免 GC 过程中堆中对象的GC标记（是否为垃圾对象）发生变化。

## 2. 堆内对象的存放

堆内的对象

![对象的组成](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/4098CB7903B94C2289BC15C32FFE94BF/8890)

## 3. 堆内的 GC 简介

![](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/1DCD0135C74446F3A70E92E6BBAAE7C1/9130)

### 2.1 Minor GC 与 年轻代

堆是 GC 的主要场所，年轻代按照容量分为 **Eden : S_0 : S_1 = 8 : 1 : 1**。
- **Eden 区**
- **Survivor 区**：存放在 GC 中生存下来的对象，分为两块 **大小相同** 的空间：
    - S_0
    - S_1

S_0 和 S_1 又被称为 **from 区** 和 **to 区**。

> S_0 和 S_1 总有一个是空的，一个是非空的。当Eden区容量满的时候，会把 Eden 和那个非空的 Survivor 区(假设是 S_0 )进行 Minor GC ，有引用指向的对象（使用**可达性分析算法**）会被保留下来并复制到另一个空的 S 区(假设是 S_1 )，并且分代年龄（分代年龄存在于对象头中）加一，然后 Eden 和 S_0 中所有垃圾对象都会被回收。如此一来，S_0 和 S_1轮流作为非空的 Survivor 区。
#### 2.1.1 担保机制

> 当回收 Eden 和非空的 survivor 区时，发现另一块空的 survivor 区空间不足以存放所有的存活下来的对象，则需要向 Old 区借用空间，称为 **担保机制**。
>
> 如果老年区也没有空间了，则触发 Full GC。
>
> 如果 Full GC 完毕还是不够，则抛出 OutOfMemory 异常。

### 2.2 Full GC 与 老年代

**老年代**：当年轻代中的对象经过多次 GC 后被保留下来的对象，如果其 **分代年龄** 到达老年代的要求，则会被放入老年代。

> 老年代满的时候会发生 **full gc，回收 老年代 + 年轻代 的所有垃圾对**象，当没有可以被回收的对象时，则发生 **OOM** （outOfMemory） 异常。


## 4. 对象何时进入老年代

#### 4.1 大对象可以直接进入老年代
这里的大对象指的是需要大量连续内存的对象，比如字符串和数组。可以设置大对象的大小阈值，超过阈值就会直接进入老年代。
这个机制的**目的是为了避免为大对象分配内存是的赋值操作而降低效率**。

#### 4.2 长期存活的对象可以直接进入老年代
虚拟机通过分代收集的思想来管理内存，给每个对象分配一个对象年龄计数器 Age。
- 当对象在 Eden 出生，经过了第一次 Minor GC，存活下来后若能被 Survivor 容纳，则移动到 Survivor 区，并将对象年龄设置为 1。
- 对象每次在 Minor GC 中存活下来，年龄就增长 1。
- 当年龄增长到阈值后被放入老年代。可以通过 `-XX:MaxTenuringThreshold` 来改变这个阈值。

#### 4.3 对象动态年龄判断机制
在那块非空的 Survivor 区，若**一批对象的总大小**超过了该区内存的 50%, 则此时大于等于该批对象中最大年龄的对象，可以直接进入老年代。
- 该机制是为了让那些可能会长期存活的对象提前进入老年代。
- 该机制的触发一般是在 Minor GC 之后。
- 内存阈值可以调整：`-XX:TargetSurvivorRatio`

----

## 5. 垃圾回收算法
### 5.1 垃圾判断的可达性分析算法

将 GC Roots 对象为根，向下搜索引用的对象，找到的对象标记为**非垃圾对象**，存在于堆中但未标记的对象都作为本次垃圾回收的**垃圾对象**。

- GC Roots 根节点可以是：线程栈的本地变量、静态变量、本地方法栈的变量等。

![可达性分析算法](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/B6085FAFED3841EDAC3F1A3E57459FE1/8882)



