---
title: 垃圾回收机制
date: 2020-9-26 9:59:50
tags: JVM
categories: JVM
mathjax: true
---

# Java 堆内的垃圾回收 GC

# JVM 垃圾回收 GC

![堆的GC](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/18FF35D98E7B4C84A637F1EDB0CD91F5/8810)

## 0. 方法区的垃圾回收

方法区的垃圾回收主要针对：**废弃的常量**和**不再使用的类型信息**。

- 废弃的常量，比如常量池中的字面量，如字符串池中的某个字符串的值已经不与任何字符串对象相同。
- 回收类型信息又被称为类型卸载。回收条件比回收常量更苛刻。
  - 一般，在大量使用反射、动态代理、CGLIB 等字节码框架，动态生成 JSP 以及 OSGi 一类频繁自定义类加载器的场景中，都需要 JVM 具有类型卸载能力，来保证方法区的剩余空间。

## 1. GC 的分类
垃圾收集 GC 按照被收集的堆内区域，分为 :

- **部分收集 Partial GC**：分为新生代收集和老年代收集。
  - **新生代收集 Minor GC**：发生在 Eden 区满的时候，**回收范围为 年轻代**。
  - **老年代收集 Major GC**：只有 CMS 收集器会单独收集老年代。
- **整堆收集 Full GC**： 发生在老年代满的时候，回收范围是**整个 Java 堆和方法区**。
> 

## 2. 堆内对象的存放

堆内的对象

![对象的组成](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/4098CB7903B94C2289BC15C32FFE94BF/8890)

## 3. 堆内的 GC 简介

![](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/1DCD0135C74446F3A70E92E6BBAAE7C1/9130)

### 3.1 Minor GC 与 年轻代

堆是 GC 的主要场所，年轻代按照容量分为 **Eden : S_0 : S_1 = 8 : 1 : 1**。
- **Eden 区**
- **Survivor 区**：存放在 GC 中生存下来的对象，分为两块 **大小相同** 的空间：
    - S_0
    - S_1

S_0 和 S_1 又被称为 **from 区** 和 **to 区**。

> S_0 和 S_1 总有一个是空的，一个是非空的。当Eden区容量满的时候，会把 Eden 和那个非空的 Survivor 区(假设是 S_0 )进行 Minor GC ，有引用指向的对象（使用**可达性分析算法**）会被保留下来并复制到另一个空的 S 区(假设是 S_1 )，并且分代年龄（分代年龄存在于对象头中）加一，然后 Eden 和 S_0 中所有垃圾对象都会被回收。如此一来，S_0 和 S_1轮流作为非空的 Survivor 区。
#### 3.1.1 担保机制

> 当回收 Eden 和非空的 survivor 区时，发现另一块空的 survivor 区空间不足以存放所有的存活下来的对象，则需要向 Old 区借用空间，称为 **担保机制**。
>
> 如果老年区也没有空间了，则触发 Full GC。
>
> 如果 Full GC 完毕还是不够，则抛出 OutOfMemory 异常。

### 3.2 Full GC 与 老年代

**老年代**：当年轻代中的对象经过多次 GC 后被保留下来的对象，如果其 **分代年龄** 到达老年代的要求，则会被放入老年代。

> 老年代满的时候会发生 **full gc，回收 老年代 + 年轻代 的所有垃圾对**象，当没有可以被回收的对象时，则发生 **OOM** （outOfMemory） 异常。


## 4. 对象何时进入老年代

#### 4.1 大对象可以直接进入老年代
这里的大对象指的是需要大量连续内存的对象，比如字符串和数组。可以设置大对象的大小阈值，超过阈值就会直接进入老年代。
这个机制的**目的是为了避免为大对象分配内存是的赋值操作而降低效率**。

#### 4.2 长期存活的对象可以直接进入老年代
虚拟机通过分代收集的思想来管理内存，给每个对象分配一个对象年龄计数器 Age。
- 当对象在 Eden 出生，经过了第一次 Minor GC，存活下来后若能被 Survivor 容纳，则移动到 Survivor 区，并将对象年龄设置为 1。
- 对象每次在 Minor GC 中存活下来，年龄就增长 1。
- 当年龄增长到阈值后被放入老年代。可以通过 `-XX:MaxTenuringThreshold` 来改变这个阈值。

#### 4.3 对象动态年龄判断机制
在那块非空的 Survivor 区，若**一批对象的总大小**超过了该区内存的 50%, 则此时大于等于该批对象中最大年龄的对象，可以直接进入老年代。
- 该机制是为了让那些可能会长期存活的对象提前进入老年代。
- 该机制的触发一般是在 Minor GC 之后。
- 内存阈值可以调整：`-XX:TargetSurvivorRatio`

----

## 5. 如何判断对象已死

判断一个对象是否还存活可以采用：

1. **引用计数法**：每引用一次计数器 +1，否则 -1
2. **可达性分析算法**

JVM 中使用的是**可达性分析算法**。

### 5.1 可达性分析算法

将 GC Roots 对象为根，向下搜索引用的对象，找到的对象标记为**非垃圾对象**，存在于堆中但未标记的对象都作为本次垃圾回收的**垃圾对象**。

可以**固定**作为 GC Roots 的对象包括：

- 虚拟机栈中引用的对象，如方法参数、局部变量等；
- 本地方法栈中引用的对象；
- 方法区中的静态类变量；
- 方法区中的常量引用，如字符串池中的引用；
- Java 虚拟机内部的引用，如基本类型的 Class 对象，常驻的异常对象，系统类加载器等；
- 被同步锁持有的对象

除了这些固定的 GC Roots 外，还可以有其他对象“临时”加入。

![可达性分析算法](http://note.youdao.com/yws/public/resource/bfce0e3d92cf4516094fe684a07f9b39/xmlnote/B6085FAFED3841EDAC3F1A3E57459FE1/8882)

## 6. 垃圾收集算法

JVM 中的垃圾回收基于**分代收集**理论：

1. **弱分代假说**：大多数对象不会长时间存活，所以分为年轻代和老年代。
2. **强分代假说**：若一个对象熬过了多次 GC，则很有可能继续生存下去，即进入老年代。
3. **跨代引用假说**：老年代中的对象引用年轻代中的对象被称为跨代引用，认为跨代引用的对象只占少数。因此在新生代中划分一小块区域，叫做记忆集，用来指明老年代的哪一块内存会存在跨代引用，这样在扫描 GC Roots 的时候只需要额外扫描这一小块区域即可，不用扫描整个老年代。

### 6.1 部分收集与整堆收集

垃圾收集 GC 按照被收集的堆内区域，分为 :

- **部分收集 Partial GC**：分为新生代收集和老年代收集。
  - **新生代收集 Minor GC**：发生在 Eden 区满的时候，**回收范围为 年轻代**。
  - **老年代收集 Major GC**：只有 CMS 收集器会单独收集老年代。
- **整堆收集 Full GC**： 发生在老年代满的时候，回收范围是**整个 Java 堆和方法区**。

#### 6.1.1 Stop the World 机制

发生 GC 时会产生 **STW （Stop the World）机制**，全程暂停 **用户应用线程** 的运行，安心进行 GC。

- Full GC 会导致 STW 时间更长，因此 JVM 调优就要减少 full GC 的次数。

Stop the World 的原因:

1. 为了判断垃圾对象：在利用可达性分析算法来判断对象是否存活时，为了防止对象的引用关系发生变化，从而避免堆中对象的 GC 标记（是否为垃圾对象）发生变化。
2. 为了整理内存碎片：垃圾回收后，存活的对象需要被复制或移动到其他内存，并更新引用地址，这是一个负重的操作。

### 6.2 垃圾回收算法

主要有：

1. 标记-清除算法
2. 标记-复制算法
3. 标记-整理算法

#### 6.2.1 标记-清除算法

先标记出所有需要回收的对象，然后统一清除。

缺点是：

1. 效率低
2. 会产生大量的内存碎片

#### 6.2.2 标记-复制算法

JVM 用该算法对**新生代**进行回收。

标记-复制算法被称为 **半区复制**。把内存平分为 2 块，每次只用一块，先标记出所有存活的对象，然后复制到另一块区域。

根据弱分代假说，大部分对象都会马上死亡，使用**Appel 式回收**进行优化：

把新生代分为 **Eden 区** + 2 块 Survivor 区。内存大小比例 **8 ：1：1**。

每次内存分配时占用 Eden 区 + 其中一块 Survivor 区，在 GC 时，把这两块中还存活的对象复制到另一块 Survivor 区，然后直接清空之前的两块区域。

- 如果另一块 Survivor 区不足以存放之前被回收的两块区域，则利用**担保机制**使对象进入老年代。

#### 6.2.3 标记-整理算法

JVM 利用该算法对**老年代**进行回收。

先标记出所有存活的对象，然后移动到内存空间的同一端，避免产生内存碎片。然后清除边界外的内存。